.. toctree::

.. highlight:: sh

===============
Developer Guide
===============


Setup Development Environment
=============================

#. Install ``pip`` and ``tox``:

   ::

      sudo apt-get install python-pip
      sudo pip install tox

#. Configure git pre-commit hook:

   ::

      sudo pip install flake8 pep8-naming
      flake8 --install-hook
      git config flake8.strict true


Building Documentation
======================

::

   tox -e doc

Output will be available at ``.tox/doc/tmp/html``. It is recommended to install
the ``webdev`` package:

::

   sudo pip install webdev

So a development web server can serve any location like this:

::

   $ webdev .tox/doc/tmp/html


Running Test Suite
==================

::

   tox -e py27,py34


Adding functions
================

Vtysh library is autogenerated from a some description dictionaries located at
via **tools/vtysh_meta.py**. In this file, the ``VTYSH_SPEC`` variable holds
all the specification of the commands the library will provide. This dictionary
is composed by *contexts*, each one containing several *commands*:

::

      'context': {
        'doc': 'Context documentation.',
        'arguments': [
            {
                'name': 'arg1',
                'doc': 'Context argument 1.'
            }
        ],
        'pre_commands': ['pre command 1', 'pre command 2 {arg1}'],
        'post_commands': ['post command'],
        'commands': [
            {
                'command': 'vtysh command {arg_a}',
                'doc': 'Documentation for the command',
                'arguments': [
                    {
                        'name': 'arg_a',
                        'doc': 'Argument for command.'
                    },
                ],
            },
            ...
         ]
      }

A *context* is a vtysh context, to get inside one a list of *pre_commands* is
run on a vtysh cli, when you are done with the context a list of
*post_commands* is executed to clean the cli.

Inside the context any number of commands can be defined. The python function
generated will be called as the vtysh command, but with underscores. This way
the first command on the example will create a function called *vtysh_command*
with *arg_a* as argument.

To add a new command to the library, a developer needs to:

#. Find if the context for the command is already defined on the dictionary.
#. If it is not defined, it has to be added.
#. Define the new command inside *commands* on the correct context.
#. Execute the generator script. To do this:

   #. Go to the ``topology_lib_vtysh`` root folder.
   #. Run ``tox`` which validates your script and prepares the py34 environment.
   #. Run ``source .tox/py34/bin/activate``.
   #. Run ``./tools/updatelib``.
   #. Run ``deactivate``.

If the vtysh command has output (by example any *show* command), a parser
function has to be defined in **parser.py**. The name of this function must be
"parse_<name_of_the_function>". For example, if a command is ``show house`` a
python function called ``show_house`` will be autogenerated and the developer
must manually define a function named ``parse_show_house`` on parser.py with a
description on how to parse the result of the vtysh command.

Usage is described on :class:`topology_lib_vtysh.library.ContextManager`

Command and argument parameters
-------------------------------

Commands and their arguments may have parameters, they need to be set properly
in these situations:

1. Commands that return output need to have the ``returns: True`` parameter.
2. Optional command arguments need to have an ``optional: True`` parameter.

Collisions between commands
...........................

It may happen that there are 2 or more vtysh commands that share the same
instructions (the actual words that make the vtysh command) but have different
types of parameters.

For example, this could be one of those cases:

- ``vtysh command ip`` where ``vtysh command`` are instructions and ``ip``
  is an argument.
- ``vtysh command group`` where ``vtysh command`` are instructions and
  ``group`` is an argument.

In that case, there must exist only one library function where its
documentation clearly explains the multiple types of parameters that it may
receive. You can find an example in the documentation for
:func:`topology_lib_vtysh.library.Configure.ip_route`.


About show-running function
...........................

The code currently is parsing only the BGP section. If an additional section
requires parsing, a new index should be added to the result dictionary, i.e.:
if vlan section parsing is to be implemented then:

#. A regex to capture only the required (vlan) section must be defined.
#. An entry to the result dictionary with vlan index should be added::

    result['vlan'] = {}

#. Any vlan related data that is parsed should be added to the vlan section
   i.e.::

       result['vlan']['vlanList'] = code_that_gets_vlan_list

#. Follow the same order that the show-running output is displayed to keep
   consistency and readability.


Adding exceptions
=================

When a commands fails (the shells gets output in a non-show command) the library
will try to determine the failure to raise a typed exception. To do so, it has
to know what kind of errors the command may show. For example::

    # asd aaa
    % Unknown command

In the above scenario, we can identify this error using a regular expression
that will match the ``% Unknown command`` output. To specify a new typed
exception edit the file ``tools/vtysh_meta.py`` and modify the
``VTYSH_EXCEPTIONS_SPEC`` dictionary mapping the name of the new exception and
a list of regular expressions for that error that will be used to try to
identify the output of a command::

    ), (
        'IncompleteCommandException',
        [
            'Command incomplete',
        ]
    )
